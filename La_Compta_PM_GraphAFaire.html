<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dessin du Point Mort - Exercice</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 950px;
            margin: 0 auto;
            padding: 20px;
            background-color: black;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            border-bottom: 5px solid #00FF36;
        }
        .title-container {
            background-color: #4a148c; /* Violet foncé */
            border-top: 5px solid #FFF98F; 
            border-bottom: 5px solid #8FFFFB;
            color: white;
            text-align: center;
			position: relative;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
			text-shadow: 2px 2px 4px rgba(0,0,0,1);
            box-shadow: 0 -8px 8px 2px rgba(255,242,18,0.4);
        }
        h1 {
            margin: 0;
            font-size: 24px;
        }
        .data-container {
            background-color: #EFDEFF;
            padding: 2px 15px 2px;
            border-radius: 8px;
            margin: 2px;
            border-left: 4px solid #4a148c;
        }
        .data-item {
            margin: 8px 0;
            font-weight: bold;
        }
        .canvas-container {
            position: relative;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        #drawingCanvas {
            background-color: #f9f9f9;
            cursor: crosshair;
            display: block;
        }
        .instructions {
            background-color: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 2px 15px 2px;
            margin-bottom: 6px;
			margin-top: 6px;
            border-radius: 6px;
            font-size: 14px;
        }
        .buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
			text-shadow: 1px 1px 2px rgba(0,0,0,1);
            box-shadow: 4px 4px 6px rgba(0,0,0,0.6);
            flex: 1;
            min-width: 120px;
        }
        #validateBtn {
            background-color: #61b865;
            color: white;
        }
        #validateBtn:hover {
            background-color: #00b50d;
        }
        #newExerciseBtn {
            background-color: #ffbf47;
            color: white;
        }
        #newExerciseBtn:hover {
            background-color: #ffa500;
        }       
        #showAnswerBtn {
            background-color: #5eabcc;
            color: white;
        }
        #showAnswerBtn:hover {
            background-color: #0088c2;
        }       
        #quitBtn {
            background-color: #ff4747;
            color: white;
        }
        #quitBtn:hover {
            background-color: #ff0000;
        }
        #clearBtn {
            background-color: #9c27b0;
            color: white;
        }
        #clearBtn:hover {
            background-color: #7b1fa2;
        }       
        button:hover {
            box-shadow: 6px 6px 8px rgba(0,0,0,0.6);
            transform: translateY(-4px);
        }
        .result {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            display: none;
        }
        .correct {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .incorrect {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .legend {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            gap: 20px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 5px;
        }
        .input-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .input-group label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .input-group input {
            width: 100px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }
        .line-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .line-btn {
            padding: 4px 6px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .line-btn:hover {
            background-color: #5a6268;
        }
        .line-btn.active {
            background-color: #4a148c;
        }
		.info-icon {
			position: absolute;
			top: 15px;
			right: 15px;
			background-color: #51FF46;
			color: black;
			border-radius: 50%;
			width: 24px;
			height: 24px;
			text-align: center;
			line-height: 24px;
			font-weight: bold;
			cursor: pointer;
			font-size: 16px;
			font-style: italic;
			font-family: serif;
			box-shadow: 0px 0px 5px rgba(0,0,0,0.5);
			transition: all 0.3s ease;
		}

		.info-icon:hover {
			background-color: #FDCF00;
			transform: scale(1.1);
		}
		
		.info-icon:hover::after {
			content: "Rappel de la théorie";
			position: absolute;
			top: -30px;
			right: 0;
			background: #333;
			color: white;
			padding: 5px 10px;
			border-radius: 4px;
			font-size: 12px;
			white-space: nowrap;
			font-style: normal;
			font-family: Arial, sans-serif;
		}

		.modal {
			display: none;
			position: fixed;
			z-index: 1000;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0,0,0,0.7);
		}

		.modal-content {
			background-color: #3c3c54;
			margin: 5% auto;
			padding: 25px;
			border-radius: 10px;
			width: 80%;
			max-width: 600px;
			border: 3px solid #51FF46;
			box-shadow: 0px 0px 20px rgba(81, 255, 70, 0.5);
			position: relative;
		}

		.close {
			color: #ff4747;
			float: right;
			font-size: 28px;
			font-weight: bold;
			cursor: pointer;
			line-height: 1;
		}

		.close:hover {
			color: #ff0000;
			text-shadow: 0px 0px 10px rgba(255, 0, 0, 0.7);
		}
		
		.theory-title {
			color: #51FF46;
			border-bottom: 2px solid #FDCF00;
			padding-bottom: 10px;
			margin-top: 0;
		}

		.theory-content {
			line-height: 1.6;
			margin-top: 15px;
			color: white;
		}
		
    </style>
</head>
<body>
    <div class="title-container">
        <h1>Dessin du Point Mort</h1>
		<div class="info-icon" onclick="showTheory()">i</div>
    </div>
    
    <div class="container">
        <div class="data-container">
            <div class="data-item">Prix de vente par pièce: <strong id="sellingPriceDisplay">50 CHF</strong></div>
            <div class="data-item">Prix d'achat par pièce: <strong id="variableCostDisplay">30 CHF</strong></div>
            <div class="data-item">Coûts fixes: <strong id="fixedCostsDisplay">2000 CHF</strong></div>
            
        </div>
        <div id="graphLimits" style="display: none;"></div>

        
        <div class="canvas-container">
            <canvas id="drawingCanvas" width="950" height="600"></canvas>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: green;"></div>
                <span>Coûts fixes</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: orange;"></div>
                <span>Coûts variables</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: red;"></div>
                <span>Coûts totaux</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: blue;"></div>
                <span>Chiffre d'affaires</span>
            </div>
        </div>
        
        <div class="line-controls">
            <button class="line-btn" data-line="fixedCosts">Dessiner Coûts fixes</button>
            <button class="line-btn" data-line="variableCosts">Dessiner Coûts variables</button>
            <button class="line-btn" data-line="totalCosts">Dessiner Coûts totaux</button>
            <button class="line-btn" data-line="revenue">Dessiner Chiffre d'affaires</button>
            <button class="line-btn" id="deleteLineBtn">Supprimer la ligne sélectionnée</button>
        </div>
        
        <div class="input-container">
            <div class="input-group">
                <label for="breakEvenQuantity">Point mort (quantité):</label>
                <input type="number" id="breakEvenQuantity" min="0" max="80">
            </div>
            <div class="input-group">
                <label for="breakEvenRevenue">Point mort (CHF):</label>
                <input type="number" id="breakEvenRevenue" min="0" max="10000">
            </div>
        </div>
        
        <div class="buttons">
            <button id="validateBtn">Valider</button>
            <button id="clearBtn">Effacer tout</button>
            <button id="newExerciseBtn">Nouvel exercice</button>
			<button id="showAnswerBtn">Afficher la solution</button>
            <button id="quitBtn">Quitter</button>
        </div>
        
        <div id="result" class="result"></div>
    </div>

		<div id="theoryModal" class="modal">
			<div class="modal-content">
				<span class="close" onclick="closeTheory()">&times;</span>
				<h2 class="theory-title">Mode d'emploi</h2>
				<div class="theory-content">
            <ol>
                <li>Sélectionner la ligne à dessiner (boutons sous le graphique)</li>
				<li>Cliquer sur le point de départ, maintener enfoncé et glissez jusqu'au point d'arrivée.</li>
				<li>Pour effacer une ligne, sélectionner le bon bouton et cliquer "Effacer la ligne sélectionnée"</li>
				<li>Cliquer sur Valider pour soumettre votre graphique</li>
            </ol>
				</div>
			</div>
		</div>	

    <script>
		document.addEventListener('keydown', function(e) {
			if (e.keyCode == 123 || // F12
				(e.ctrlKey && e.shiftKey && e.keyCode == 73) || // Ctrl+Shift+I
				(e.ctrlKey && e.keyCode == 85)) { // Ctrl+U
				e.preventDefault();
			}
		});
		
        // Variables globales pour les données de l'exercice
        let sellingPrice, variableCost, fixedCosts;
        let breakEvenQuantity, breakEvenRevenue;
        
        // Variables pour les limites du graphique (seront calculées dynamiquement)
        let maxQuantity, maxRevenue;
        
        // Variables pour le dessin
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let currentLine = null;
        let selectedLine = null;
        let drawnLines = {
            fixedCosts: null,
            variableCosts: null,
            totalCosts: null,
            revenue: null
        };
        
        // Configuration du graphique
        const padding = 50;
        let graphWidth, graphHeight, xScale, yScale;
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            generateNewExercise();
            setupEventListeners();
            setupLineControls();
        });
        
        function generateNewExercise() {
            // Générer des valeurs aléatoires pour l'exercice
            sellingPrice = Math.floor(Math.random() * 40) + 40; // 40-80 CHF
			const percentage = Math.floor(Math.random() * 20) + 40; // 30-60%
			variableCost = Math.round(sellingPrice * percentage / 100);
            
            // Coûts fixes par tranche de 500 (entre 1000 et 4000 CHF)
            const fixedCostsOptions = [1000, 1250, 1500, 2000, 2500, 3000];
            fixedCosts = fixedCostsOptions[Math.floor(Math.random() * fixedCostsOptions.length)];
            
            // Calculer le point mort théorique
            breakEvenQuantity = Math.ceil(fixedCosts / (sellingPrice - variableCost));
            breakEvenRevenue = breakEvenQuantity * sellingPrice;
            
            // Calculer les limites dynamiques du graphique
            const marginQuantity = Math.floor(Math.random() * 21) + 30; // 30-50 unités
            const marginRevenue = Math.floor(Math.random() * 2001) + 1000; // 1000-3000 CHF
            
			maxQuantity = Math.ceil(Math.max(breakEvenQuantity + marginQuantity, 10) / 10) * 10;
			maxRevenue = Math.ceil(Math.max(breakEvenRevenue + marginRevenue, 100) / 500) * 500;
            
            // Mettre à jour l'affichage des données
            document.getElementById('sellingPriceDisplay').textContent = sellingPrice + ' CHF';
            document.getElementById('variableCostDisplay').textContent = variableCost + ' CHF';
            document.getElementById('fixedCostsDisplay').textContent = fixedCosts + ' CHF';
            document.getElementById('graphLimits').textContent = `0-${maxQuantity} unités, 0-${maxRevenue.toLocaleString()} CHF`;
            
            // Recalculer les échelles
            graphWidth = canvas.width - 2 * padding;
            graphHeight = canvas.height - 2 * padding;
            xScale = graphWidth / maxQuantity;
            yScale = graphHeight / maxRevenue;
            
            // Réinitialiser le dessin
            clearDrawing();
            drawGrid();
        }
        
        function setupEventListeners() {
            // Événements de dessin
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Boutons
            document.getElementById('validateBtn').addEventListener('click', validateDrawing);
            document.getElementById('clearBtn').addEventListener('click', clearDrawing);
            document.getElementById('showAnswerBtn').addEventListener('click', showAnswer);
            document.getElementById('newExerciseBtn').addEventListener('click', generateNewExercise);
            document.getElementById('quitBtn').addEventListener('click', function() {
                
                    window.close();
                
            });
            
            // Inputs pour le point mort
            document.getElementById('breakEvenQuantity').addEventListener('change', updateBreakEvenFromInputs);
            document.getElementById('breakEvenRevenue').addEventListener('change', updateBreakEvenFromInputs);
        }
        
        function setupLineControls() {
            const lineBtns = document.querySelectorAll('.line-btn[data-line]');
            lineBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    // Désactiver tous les boutons
                    lineBtns.forEach(b => b.classList.remove('active'));
                    // Activer le bouton cliqué
                    this.classList.add('active');
                    selectedLine = this.dataset.line;
                });
            });
            
            document.getElementById('deleteLineBtn').addEventListener('click', function() {
                if (selectedLine && drawnLines[selectedLine]) {
                    drawnLines[selectedLine] = null;
                    drawGrid();
                    updateBreakEvenInputs();
                }
            });
        }
        
        function drawGrid() {
            // Effacer le canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner le fond
            ctx.fillStyle = '#E4FCE1';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner la zone du graphique
            ctx.fillStyle = 'white';
            ctx.fillRect(padding, padding, graphWidth, graphHeight);
            
            // Dessiner le quadrillage principal
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            
            // Quadrillage vertical (tous les 10 unités ou adapté si maxQuantity petit)
            const verticalStep = 10; // Toujours 10 unités
            for (let i = 0; i <= maxQuantity; i += verticalStep) {
                const x = padding + i * xScale;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + graphHeight);
                ctx.stroke();
            }
            
            // Quadrillage horizontal (adapté à la taille de maxRevenue)
            const horizontalStep = 500; // Toujours 500 CHF
            for (let i = 0; i <= maxRevenue; i += horizontalStep) {
                const y = padding + graphHeight - i * yScale;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + graphWidth, y);
                ctx.stroke();
            }
            
            // Dessiner le quadrillage secondaire plus fin
            ctx.strokeStyle = '#545454';
            ctx.lineWidth = 0.5;
            
            // Quadrillage vertical fin
            for (let i = 1; i < maxQuantity; i += 1) {
                const x = padding + i * xScale;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + graphHeight);
                ctx.stroke();
            }
            
            // Quadrillage horizontal fin (tous les 100 CHF)
            for (let i = 100; i < maxRevenue; i += 100) {
                const y = padding + graphHeight - i * yScale;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + graphWidth, y);
                ctx.stroke();
            }
            
            // Dessiner les axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Axe Y
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + graphHeight);
            // Axe X
            ctx.moveTo(padding, padding + graphHeight);
            ctx.lineTo(padding + graphWidth, padding + graphHeight);
            ctx.stroke();
            
            // Graduations et étiquettes de l'axe X (quantité)
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            for (let i = 0; i <= maxQuantity; i += verticalStep) {
                const x = padding + i * xScale;
                ctx.beginPath();
                ctx.moveTo(x, padding + graphHeight);
                ctx.lineTo(x, padding + graphHeight + 5);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillText(i, x, padding + graphHeight + 20);
            }
            
            // Graduations et étiquettes de l'axe Y (CHF)
            ctx.textAlign = 'right';
            for (let i = 0; i <= maxRevenue; i += horizontalStep) {
                const y = padding + graphHeight - i * yScale;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding - 5, y);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillText(i.toLocaleString(), padding - 10, y + 4);
            }
            
            // Étiquettes des axes
            ctx.save();
            ctx.translate(padding - 40, padding + graphHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.font = '14px Arial';
            ctx.fillText('CHF', 0, 0);
            ctx.restore();
            
            ctx.textAlign = 'center';
            ctx.fillText('Quantité', padding + graphWidth / 2, padding + graphHeight + 40);
            
            // Redessiner les lignes déjà tracées
            redrawLines();
        }
        
        function startDrawing(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Vérifier si on est dans la zone du graphique
            if (x >= padding && x <= padding + graphWidth && 
                y >= padding && y <= padding + graphHeight) {
                
                isDrawing = true;
                currentLine = {
                    startX: x,
                    startY: y,
                    endX: x,
                    endY: y,
                    type: selectedLine || identifyLineTypeFromPosition(x, y)
                };
            }
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Limiter aux limites du graphique
            currentLine.endX = Math.max(padding, Math.min(padding + graphWidth, x));
            currentLine.endY = Math.max(padding, Math.min(padding + graphHeight, y));
            
            // Redessiner le graphique avec la ligne en cours
            drawGrid();
            drawTemporaryLine();
        }
        
        function drawTemporaryLine() {
            if (!currentLine) return;
            
            ctx.strokeStyle = 'purple';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(currentLine.startX, currentLine.startY);
            ctx.lineTo(currentLine.endX, currentLine.endY);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function stopDrawing() {
            if (!isDrawing) return;
            
            isDrawing = false;
            
            // Identifier le type de ligne si non spécifié
            if (!currentLine.type) {
                currentLine.type = identifyLineType(currentLine);
            }
            
            if (currentLine.type) {
                drawnLines[currentLine.type] = {
                    startX: currentLine.startX,
                    startY: currentLine.startY,
                    endX: currentLine.endX,
                    endY: currentLine.endY
                };
                
                // Mettre à jour les inputs du point mort
                updateBreakEvenInputs();
            }
            
            currentLine = null;
            drawGrid();
        }
        
        function identifyLineTypeFromPosition(x, y) {
            // Si proche de l'axe des X (bas du graphique), probablement chiffre d'affaires
            if (y > padding + graphHeight - 20) return 'revenue';
            
            // Si proche de l'axe des Y (gauche du graphique), probablement coûts variables
            if (x < padding + 20) return 'variableCosts';
            
            // Si proche de la ligne des coûts fixes théorique
            const fixedCostsY = padding + graphHeight - fixedCosts * yScale;
            if (Math.abs(y - fixedCostsY) < 20) return 'fixedCosts';
            
            // Sinon, coûts totaux par défaut
            return 'totalCosts';
        }
        
        function identifyLineType(line) {
            const deltaX = Math.abs(line.endX - line.startX);
            const deltaY = Math.abs(line.endY - line.startY);
            
            // Si c'est une ligne presque horizontale (coûts fixes)
            if (deltaY < 10 && deltaX > 50) {
                return 'fixedCosts';
            }
            
            // Si la ligne part du point (0, 0) ou proche
            const startQuantity = Math.round((line.startX - padding) / xScale);
            const startRevenue = Math.round((padding + graphHeight - line.startY) / yScale);
            
            if (startQuantity === 0 && startRevenue === 0) {
                // Si elle monte rapidement, c'est le chiffre d'affaires
                if (line.endY < line.startY - 100) return 'revenue';
                // Sinon, coûts variables
                return 'variableCosts';
            }
            
            // Si la ligne part du point (0, coûts fixes) ou proche
            if (Math.abs(startRevenue - fixedCosts) < 200 && startQuantity === 0) {
                return 'totalCosts';
            }
            
            // Sinon, ne pas enregistrer cette ligne
            return null;
        }
        
        function redrawLines() {
            // Dessiner les coûts fixes (ligne verte)
            if (drawnLines.fixedCosts) {
                ctx.strokeStyle = 'green';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(drawnLines.fixedCosts.startX, drawnLines.fixedCosts.startY);
                ctx.lineTo(drawnLines.fixedCosts.endX, drawnLines.fixedCosts.endY);
                ctx.stroke();
            }
            
            // Dessiner les coûts variables (ligne orange)
            if (drawnLines.variableCosts) {
                ctx.strokeStyle = 'orange';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(drawnLines.variableCosts.startX, drawnLines.variableCosts.startY);
                ctx.lineTo(drawnLines.variableCosts.endX, drawnLines.variableCosts.endY);
                ctx.stroke();
            }
            
            // Dessiner les coûts totaux (ligne rouge)
            if (drawnLines.totalCosts) {
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(drawnLines.totalCosts.startX, drawnLines.totalCosts.startY);
                ctx.lineTo(drawnLines.totalCosts.endX, drawnLines.totalCosts.endY);
                ctx.stroke();
            }
            
            // Dessiner le chiffre d'affaires (ligne bleue)
            if (drawnLines.revenue) {
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(drawnLines.revenue.startX, drawnLines.revenue.startY);
                ctx.lineTo(drawnLines.revenue.endX, drawnLines.revenue.endY);
                ctx.stroke();
            }
            
            // Dessiner le point mort si toutes les lignes sont tracées
            drawBreakEvenPoint();
        }
        
        function drawBreakEvenPoint() {
            if (!drawnLines.totalCosts || !drawnLines.revenue) return;
            
            // Calculer le point d'intersection entre coûts totaux et chiffre d'affaires
            const intersection = findIntersection(
                drawnLines.totalCosts, drawnLines.revenue
            );
            
            if (!intersection) return;
            
            // Dessiner le point d'intersection
            ctx.fillStyle = 'purple';
            ctx.beginPath();
            ctx.arc(intersection.x, intersection.y, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Ajouter une étiquette
            ctx.fillStyle = 'purple';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            const quantity = Math.round((intersection.x - padding) / xScale);
            const revenue = Math.round((padding + graphHeight - intersection.y) / yScale);
            ctx.fillText(`Point mort: ${quantity} unités, ${revenue.toLocaleString()} CHF`, intersection.x + 10, intersection.y - 10);
        }
        
        function clearDrawing() {
            drawnLines = {
                fixedCosts: null,
                variableCosts: null,
                totalCosts: null,
                revenue: null
            };
            document.getElementById('result').style.display = 'none';
            updateBreakEvenInputs();
            drawGrid();
        }
        
        function validateDrawing() {
            // Vérifier si les quatre lignes ont été dessinées
            if (!drawnLines.fixedCosts || !drawnLines.variableCosts || !drawnLines.totalCosts || !drawnLines.revenue) {
                alert("Veuillez dessiner les quatre lignes avant de valider.");
                return;
            }
            
            // Calculer le point d'intersection entre coûts totaux et chiffre d'affaires
            const intersection = findIntersection(
                drawnLines.totalCosts, drawnLines.revenue
            );
            
            if (!intersection) {
                showResult(false, "Impossible de déterminer le point d'intersection.");
                return;
            }
            
            // Convertir les coordonnées du canvas en valeurs réelles
            const quantity = Math.round((intersection.x - padding) / xScale);
            const revenue = Math.round((padding + graphHeight - intersection.y) / yScale);
            
            // Vérifier avec une large tolérance
            const quantityTolerance = Math.max(5, Math.round(maxQuantity * 0.05)); // 5% de maxQuantity ou 5 unités minimum
            const revenueTolerance = Math.max(200, Math.round(maxRevenue * 0.05)); // 5% de maxRevenue ou 200 CHF minimum
            
            const isQuantityCorrect = Math.abs(quantity - breakEvenQuantity) <= quantityTolerance;
            const isRevenueCorrect = Math.abs(revenue - breakEvenRevenue) <= revenueTolerance;
            
            // Dessiner les lignes correctes en pointillés
            drawCorrectLines();
            
            if (isQuantityCorrect && isRevenueCorrect) {
                showResult(true, `Correct! Le point mort est à ${quantity} unités (${revenue.toLocaleString()} CHF).`);
            } else {
                showResult(false, `Incorrect. Votre point mort est à ${quantity} unités (${revenue.toLocaleString()} CHF), mais il devrait être à ${breakEvenQuantity} unités (${breakEvenRevenue.toLocaleString()} CHF).`);
            }
        }
        
        function drawCorrectLines() {
            // Coûts fixes (ligne horizontale à y = fixedCosts)
            const fixedCostsY = padding + graphHeight - fixedCosts * yScale;
            
            // Coûts variables (commence à (0, 0) et finit à (maxQuantity, variableCost*maxQuantity))
            const variableCostsEndY = padding + graphHeight - (variableCost * maxQuantity) * yScale;
            
            // Coûts totaux (commence à (0, fixedCosts) et finit à (maxQuantity, fixedCosts + variableCost*maxQuantity))
            const totalCostsEndY = padding + graphHeight - (fixedCosts + variableCost * maxQuantity) * yScale;
            
            // Chiffre d'affaires (commence à (0, 0) et finit à (maxQuantity, sellingPrice*maxQuantity))
            const revenueEndY = padding + graphHeight - (sellingPrice * maxQuantity) * yScale;
            
            // Dessiner les lignes correctes en pointillés
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            
            // Coûts fixes
            ctx.strokeStyle = 'green';
            ctx.beginPath();
            ctx.moveTo(padding, fixedCostsY);
            ctx.lineTo(padding + graphWidth, fixedCostsY);
            ctx.stroke();
            
            // Coûts variables
            ctx.strokeStyle = 'orange';
            ctx.beginPath();
            ctx.moveTo(padding, padding + graphHeight);
            ctx.lineTo(padding + graphWidth, variableCostsEndY);
            ctx.stroke();
            
            // Coûts totaux
            ctx.strokeStyle = 'red';
            ctx.beginPath();
            ctx.moveTo(padding, fixedCostsY);
            ctx.lineTo(padding + graphWidth, totalCostsEndY);
            ctx.stroke();
            
            // Chiffre d'affaires
            ctx.strokeStyle = 'blue';
            ctx.beginPath();
            ctx.moveTo(padding, padding + graphHeight);
            ctx.lineTo(padding + graphWidth, revenueEndY);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }
        
        function findIntersection(line1, line2) {
            // Calculer les équations des droites
            const m1 = (line1.endY - line1.startY) / (line1.endX - line1.startX);
            const b1 = line1.startY - m1 * line1.startX;
            
            const m2 = (line2.endY - line2.startY) / (line2.endX - line2.startX);
            const b2 = line2.startY - m2 * line2.startX;
            
            // Vérifier si les droites sont parallèles
            if (Math.abs(m1 - m2) < 0.001) {
                return null;
            }
            
            // Calculer le point d'intersection
            const x = (b2 - b1) / (m1 - m2);
            const y = m1 * x + b1;
            
            // Vérifier si le point d'intersection est dans les segments
            if (x < Math.min(line1.startX, line1.endX) || x > Math.max(line1.startX, line1.endX) ||
                x < Math.min(line2.startX, line2.endX) || x > Math.max(line2.startX, line2.endX)) {
                return null;
            }
            
            return { x, y };
        }
        
        function showResult(isCorrect, message) {
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = message;
            resultDiv.className = isCorrect ? 'result correct' : 'result incorrect';
            resultDiv.style.display = 'block';
        }
        
        function updateBreakEvenInputs() {
            if (!drawnLines.totalCosts || !drawnLines.revenue) {
                document.getElementById('breakEvenQuantity').value = '';
                document.getElementById('breakEvenRevenue').value = '';
                return;
            }
            
            const intersection = findIntersection(drawnLines.totalCosts, drawnLines.revenue);
            if (!intersection) return;
            
            const quantity = Math.round((intersection.x - padding) / xScale);
            const revenue = Math.round((padding + graphHeight - intersection.y) / yScale);
            
            document.getElementById('breakEvenQuantity').value = quantity;
            document.getElementById('breakEvenRevenue').value = revenue;
        }
        
        function updateBreakEvenFromInputs() {
            const quantity = parseInt(document.getElementById('breakEvenQuantity').value) || 0;
            const revenue = parseInt(document.getElementById('breakEvenRevenue').value) || 0;
            
            if (quantity === 0 && revenue === 0) return;
            
            // Calculer les nouvelles positions des lignes basées sur le point mort
            const x = padding + quantity * xScale;
            const y = padding + graphHeight - revenue * yScale;
            
            // Mettre à jour la ligne des coûts totaux pour passer par ce point
            if (drawnLines.fixedCosts) {
                const fixedY = drawnLines.fixedCosts.startY;
                drawnLines.totalCosts = {
                    startX: padding,
                    startY: fixedY,
                    endX: x,
                    endY: y
                };
            }
            
            // Mettre à jour la ligne du chiffre d'affaires pour passer par ce point
            drawnLines.revenue = {
                startX: padding,
                startY: padding + graphHeight,
                endX: x,
                endY: y
            };
            
            drawGrid();
        }
        
        function showAnswer() {
            // Effacer les dessins actuels
            clearDrawing();
            
            // Dessiner les bonnes lignes
            // Coûts fixes (ligne horizontale à y = fixedCosts)
            const fixedCostsY = padding + graphHeight - fixedCosts * yScale;
            drawnLines.fixedCosts = {
                startX: padding,
                startY: fixedCostsY,
                endX: padding + graphWidth,
                endY: fixedCostsY
            };
            
            // Coûts variables (commence à (0, 0) et finit à (maxQuantity, variableCost*maxQuantity))
            const variableCostsEndY = padding + graphHeight - (variableCost * maxQuantity) * yScale;
            drawnLines.variableCosts = {
                startX: padding,
                startY: padding + graphHeight,
                endX: padding + graphWidth,
                endY: variableCostsEndY
            };
            
            // Coûts totaux (commence à (0, fixedCosts) et finit à (maxQuantity, fixedCosts + variableCost*maxQuantity))
            const totalCostsEndY = padding + graphHeight - (fixedCosts + variableCost * maxQuantity) * yScale;
            drawnLines.totalCosts = {
                startX: padding,
                startY: fixedCostsY,
                endX: padding + graphWidth,
                endY: totalCostsEndY
            };
            
            // Chiffre d'affaires (commence à (0, 0) et finit à (maxQuantity, sellingPrice*maxQuantity))
            const revenueEndY = padding + graphHeight - (sellingPrice * maxQuantity) * yScale;
            drawnLines.revenue = {
                startX: padding,
                startY: padding + graphHeight,
                endX: padding + graphWidth,
                endY: revenueEndY
            };
            
            // Redessiner le graphique avec les bonnes lignes
            drawGrid();
            
            // Afficher le résultat
            showResult(true, `Solution: Le point mort est à ${breakEvenQuantity} unités (${breakEvenRevenue.toLocaleString()} CHF).`);
        }
		
		// Fonctions pour le pop-up théorique
		function showTheory() {
			document.getElementById('theoryModal').style.display = 'block';
		}

		function closeTheory() {
			document.getElementById('theoryModal').style.display = 'none';
		}

		// Fermer le pop-up si on clique en dehors
		window.onclick = function(event) {
			const modal = document.getElementById('theoryModal');
			if (event.target === modal) {
				closeTheory();
			}
		}		
    </script>
</body>
</html>